---
title: "Hands-on Exercise 4"
description: |
  Work in Progress (Will be adding my own notes)
author:
  - name: Nor Aisyah
    url: https://www.linkedin.com/in/nor-aisyah/
date: 09-03-2021
output:
  distill::distill_article:
    self_contained: false
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```

# Work in Progress (will be adding my notes later tonight) :)


# 1. Installing and Loading the R packages
```{r echo=TRUE, eval=TRUE}
packages = c('maptools', 'sf', 'raster','spatstat', 'tmap')
for (p in packages){
if(!require(p, character.only = T)){
install.packages(p)
}
library(p,character.only = T)
}
```

# 2.Geospatial Data Wrangling
# 2.1 Importing the geospatial data
```{r echo=TRUE, eval=TRUE}
childcare_sf <- st_read("data/child-care-services-geojson.geojson") %>%
  st_transform(crs = 3414)
sg_sf <- st_read(dsn = "data", layer="CostalOutline")
mpsz_sf <- st_read(dsn = "data", 
                layer = "MP14_SUBZONE_WEB_PL")
```


# 2.2 Retrieve referencing system information of geospatial data
```{r echo=TRUE, eval=TRUE}
st_crs(childcare_sf)
st_crs(mpsz_sf)
st_crs(sg_sf)
```

# 2.3 Assign correct crs to mpsz_sf and sg_sf simple feature data frames
```{r echo=TRUE, eval=TRUE}
mpsz_sf <- st_as_sf(mpsz_sf)
mpsz_sf <- st_transform(mpsz_sf, crs= 3414)

sg_sf <- st_as_sf(sg_sf)
sg_sf <- st_transform(sg_sf, crs= 3414)
```

# 2.4 Mapping the geospatial data sets
```{r echo=TRUE, eval=TRUE}
tm_shape(sg_sf) +
  tm_polygons() +
tm_shape(mpsz_sf) +
  tm_polygons() +
tm_shape(childcare_sf)+
  tm_dots()
```

# 2.5 Creating a Pin Map
```{r echo=TRUE, eval=TRUE}
tmap_mode('view')
tm_shape(childcare_sf)+
  tm_dots()
```

```{r echo=TRUE, eval=TRUE}
tmap_mode('plot')
```

# 3. Geospatial Data wrangling
## 3.1 Converting sf data frames to sp’s Spatial* class
```{r echo=TRUE, eval=TRUE}
childcare <- as_Spatial(childcare_sf)
mpsz <- as_Spatial(mpsz_sf)
sg <- as_Spatial(sg_sf)
```

### 3.1.1 Display information of 3 Spatial* classes
```{r echo=TRUE, eval=TRUE}
childcare
mpsz 
sg 
```


## 3.2 Converting the Spatial* class into generic sp format
```{r echo=TRUE, eval=TRUE}
childcare_sp <- as(childcare, "SpatialPoints")
sg_sp <- as(sg, "SpatialPolygons")
```

## 3.3 Converting the generic sp format into spatstat’s ppp format
```{r echo=TRUE, eval=TRUE}
childcare_ppp <- as(childcare_sp, "ppp")
childcare_ppp
```

### 3.3.1 Plot childcare_ppp 
```{r echo=TRUE, eval=TRUE}
plot(childcare_ppp)
```

### 3.3.2 See summary statistics 
```{r echo=TRUE, eval=TRUE}
summary(childcare_ppp)
```

## 3.4  Handling duplicated points

### 3.4.1 Check for duplicates
```{r echo=TRUE, eval=TRUE}
any(duplicated(childcare_ppp))
```

### 3.4.2 Count number of co-indicence point
```{r echo=TRUE, eval=TRUE}
multiplicity(childcare_ppp)
```

### 3.4.3 See locations that have more than 1 point event
- The output will show the total number of duplicated point events

```{r echo=TRUE, eval=TRUE}
sum(multiplicity(childcare_ppp) > 1)
```

### 3.4.4 View locations of duplicate point events
```{r echo=TRUE, eval=TRUE}
tmap_mode('view')
tm_shape(childcare) +
  tm_dots(alpha=0.4, 
          size=0.05)
tmap_mode('plot')

```

### 3.4.5 Spot duplicate points from map shown above
- Use jittering approach: Add a small perturbation to the duplicate points so that they do not occupy the exact same space

```{r echo=TRUE, eval=TRUE}
childcare_ppp_jit <- rjitter(childcare_ppp, 
                             retry=TRUE, 
                             nsim=1, 
                             drop=TRUE)
```


#### 3.4.5.1 Check if any dusplicated point in this geospatial data
```{r echo=TRUE, eval=TRUE}
any(duplicated(childcare_ppp_jit))
```

## 3.5 Creating owin object
```{r echo=TRUE, eval=TRUE}
sg_owin <- as(sg_sp, "owin")
plot(sg_owin)
```

```{r echo=TRUE, eval=TRUE}
summary(sg_owin)
```

### 3.5.1 Combining point events object and owin object
```{r echo=TRUE, eval=TRUE}
childcareSG_ppp = childcare_ppp[sg_owin]
```

```{r echo=TRUE, eval=TRUE}
summary(sg_owin)
```

# 4. First-order Spatial Point Patterns Analysis
## 4.1 Kernel Density Estimation
### 4.1.1 Computing kernel density estimation using automatic bandwidth selection method
```{r echo=TRUE, eval=TRUE}
kde_childcareSG_bw <- density(childcareSG_ppp,
                              sigma=bw.diggle,
                              edge=TRUE,
                            kernel="gaussian") 
```

```{r echo=TRUE, eval=TRUE}
plot(kde_childcareSG_bw)
```

### 4.1.2 Retrieve the bandwidth used to compute the kde layer
```{r echo=TRUE, eval=TRUE}
bw <- bw.diggle(childcareSG_ppp)
bw
```

### 4.1.2 Rescalling KDE 
- To convert the unit of measurement from meter to kilometer.

```{r echo=TRUE, eval=TRUE}
childcareSG_ppp.km <- rescale(childcareSG_ppp, 1000, "km")
```

### 4.1.3 Plotkde map
```{r echo=TRUE, eval=TRUE}
kde_childcareSG.bw <- density(childcareSG_ppp.km, sigma=bw.diggle, edge=TRUE, kernel="gaussian")
plot(kde_childcareSG.bw)
```

### 4.1.3 Working with different automatic badwidth methods
```{r echo=TRUE, eval=TRUE}
 bw.CvL(childcareSG_ppp.km)
```

```{r echo=TRUE, eval=TRUE}
bw.scott(childcareSG_ppp.km)
```

```{r echo=TRUE, eval=TRUE}
bw.ppl(childcareSG_ppp.km)
```

```{r echo=TRUE, eval=TRUE}
bw.diggle(childcareSG_ppp.km)
```

#### 4.1.3.1 Compare output of using bw.diggle and bw.ppl methods
```{r echo=TRUE, eval=TRUE}
kde_childcareSG.ppl <- density(childcareSG_ppp.km, 
                               sigma=bw.ppl, 
                               edge=TRUE,
                               kernel="gaussian")
par(mfrow=c(1,2))
plot(kde_childcareSG.bw, main = "bw.diggle")
plot(kde_childcareSG.ppl, main = "bw.ppl")
```


### 4.1.4 Working with different kernel methods
```{r echo=TRUE, eval=TRUE}
par(mfrow=c(2,2))
plot(density(childcareSG_ppp.km, 
             sigma=bw.ppl, 
             edge=TRUE, 
             kernel="gaussian"), 
     main="Gaussian")
plot(density(childcareSG_ppp.km, 
             sigma=bw.ppl, 
             edge=TRUE, 
             kernel="epanechnikov"), 
     main="Epanechnikov")
plot(density(childcareSG_ppp.km, 
             sigma=bw.ppl, 
             edge=TRUE, 
             kernel="quartic"), 
     main="Quartic")
plot(density(childcareSG_ppp.km, 
             sigma=bw.ppl, 
             edge=TRUE, 
             kernel="disc"), 
     main="Disc")
```

### 4.1.5 Fixed and Adaptive KDE

#### 4.1.5.1 Computing KDE by using fixed bandwidth
```{r echo=TRUE, eval=TRUE}
kde_childcareSG_600 <- density(childcareSG_ppp.km, sigma=0.6, edge=TRUE, kernel="gaussian")
plot(kde_childcareSG_600)
```

#### 4.1.5.2 Computing KDE by using adaptive bandwidth
```{r echo=TRUE, eval=TRUE}
kde_childcareSG_adaptive <- adaptive.density(childcareSG_ppp.km, method="kernel")
plot(kde_childcareSG_adaptive)
```

#### 4.1.5.3 Compare fixed and adaptive kernel density estimation outputs
```{r echo=TRUE, eval=TRUE}
par(mfrow=c(1,2))
plot(kde_childcareSG.bw, main = "Fixed bandwidth")
plot(kde_childcareSG_adaptive, main = "Adaptive bandwidth")
```

### 4.1.6 Converting KDE output into grid object
```{r echo=TRUE, eval=TRUE}
gridded_kde_childcareSG_bw <- as.SpatialGridDataFrame.im(kde_childcareSG.bw)
spplot(gridded_kde_childcareSG_bw)
```

#### 4.1.6.1 Converting gridded output into raster
```{r echo=TRUE, eval=TRUE}
kde_childcareSG_bw_raster <- raster(gridded_kde_childcareSG_bw)
kde_childcareSG_bw_raster
```

#### 4.1.6.2 Assigning projection systems
- Because the above output show NA for crs

```{r echo=TRUE, eval=TRUE}
projection(kde_childcareSG_bw_raster) <- CRS("+init=EPSG:3414")
kde_childcareSG_bw_raster
```

### 4.1.7 Visualising the output in tmap
```{r echo=TRUE, eval=TRUE}
tm_shape(kde_childcareSG_bw_raster) + 
  tm_raster("v") +
  tm_layout(legend.position = c("right", "bottom"), frame = FALSE)
```

### 4.1.8 Comparing Spatial Point Patterns using KDE
#### 4.1.8.1 Extracting study area
- Extract the target planning areas first before plotting

```{r echo=TRUE, eval=TRUE}
pg = mpsz[mpsz@data$PLN_AREA_N == "PUNGGOL",]
tm = mpsz[mpsz@data$PLN_AREA_N == "TAMPINES",]
ck = mpsz[mpsz@data$PLN_AREA_N == "CHOA CHU KANG",]
jw = mpsz[mpsz@data$PLN_AREA_N == "JURONG WEST",]

par(mfrow=c(2,2))
plot(pg, main = "Ponggol")
plot(tm, main = "Tampines")
plot(ck, main = "Choa Chu Kang")
plot(jw, main = "Jurong West")
```

#### 4.1.8.2 Converting the spatial point data frame into generic sp format
```{r echo=TRUE, eval=TRUE}
pg_sp = as(pg, "SpatialPolygons")
tm_sp = as(tm, "SpatialPolygons")
ck_sp = as(ck, "SpatialPolygons")
jw_sp = as(jw, "SpatialPolygons")
```

#### 4.1.8.3 Creating owin object
```{r echo=TRUE, eval=TRUE}
pg_owin = as(pg_sp, "owin")
tm_owin = as(tm_sp, "owin")
ck_owin = as(ck_sp, "owin")
jw_owin = as(jw_sp, "owin")
```

#### 4.1.8.4 Combining childcare points and the study area
- Extract childcare that is within the specific region to do our analysis later on

```{r echo=TRUE, eval=TRUE}
childcare_pg_ppp = childcare_ppp_jit[pg_owin]
childcare_tm_ppp = childcare_ppp_jit[tm_owin]
childcare_ck_ppp = childcare_ppp_jit[ck_owin]
childcare_jw_ppp = childcare_ppp_jit[jw_owin]
```

- Transform the unit of measurement from meter to kilometer.

```{r echo=TRUE, eval=TRUE}
childcare_pg_ppp.km = rescale(childcare_pg_ppp, 1000, "km")
childcare_tm_ppp.km = rescale(childcare_tm_ppp, 1000, "km")
childcare_ck_ppp.km = rescale(childcare_ck_ppp, 1000, "km")
childcare_jw_ppp.km = rescale(childcare_jw_ppp, 1000, "km")
```

- Plot these four study areas and the locations of the childcare centres.

```{r echo=TRUE, eval=TRUE}
par(mfrow=c(2,2))
plot(childcare_pg_ppp.km, main="Punggol")
plot(childcare_tm_ppp.km, main="Tampines")
plot(childcare_ck_ppp.km, main="Choa Chu Kang")
plot(childcare_jw_ppp.km, main="Jurong West")
```

#### 4.1.8.5 Computing KDE
```{r echo=TRUE, eval=TRUE}
par(mfrow=c(2,2))
plot(density(childcare_pg_ppp.km, 
             sigma=bw.diggle, 
             edge=TRUE, 
             kernel="gaussian"),
     main="Punggol")
plot(density(childcare_tm_ppp.km, 
             sigma=bw.diggle, 
             edge=TRUE, 
             kernel="gaussian"),
     main="Tempines")
plot(density(childcare_ck_ppp.km, 
             sigma=bw.diggle, 
             edge=TRUE, 
             kernel="gaussian"),
     main="Choa Chu Kang")
plot(density(childcare_jw_ppp.km, 
             sigma=bw.diggle, 
             edge=TRUE, 
             kernel="gaussian"),
     main="JUrong West")
```

#### 4.1.8.6 Computing fixed bandwidth KDE
```{r echo=TRUE, eval=TRUE}
par(mfrow=c(2,2))
plot(density(childcare_ck_ppp.km, 
             sigma=0.25, 
             edge=TRUE, 
             kernel="gaussian"),
     main="Chou Chu Kang")
plot(density(childcare_jw_ppp.km, 
             sigma=0.25, 
             edge=TRUE, 
             kernel="gaussian"),
     main="JUrong West")
plot(density(childcare_pg_ppp.km, 
             sigma=0.25, 
             edge=TRUE, 
             kernel="gaussian"),
     main="Punggol")
plot(density(childcare_tm_ppp.km, 
             sigma=0.25, 
             edge=TRUE, 
             kernel="gaussian"),
     main="Tampines")
```

### 4.1.9 Nearest Neighbour Analysis
#### 4.1.9.1 Testing spatial point patterns using Clark and Evans Test
```{r echo=TRUE, eval=TRUE}
clarkevans.test(childcareSG_ppp,
                correction="none",
                clipregion="sg_owin",
                alternative=c("clustered"),
                nsim=99)
```

#### 4.1.9.2 Clark and Evans Test: Choa Chu Kang planning area
```{r echo=TRUE, eval=TRUE}
clarkevans.test(childcare_ck_ppp,
                correction="none",
                clipregion=NULL,
                alternative=c("two.sided"),
                nsim=999)
```

#### 4.1.9.3 Clark and Evans Test: Tampines planning area
```{r echo=TRUE, eval=TRUE}
clarkevans.test(childcare_tm_ppp,
                correction="none",
                clipregion=NULL,
                alternative=c("two.sided"),
                nsim=999)
```


# 5. Second-order Spatial Point Patterns Analysis
## 5.1 Analysing Spatial Point Process Using G-Function
### 5.1.1 Choa Chu Kang planning area
#### 5.1.1.1 Computing G-function estimation
```{r echo=TRUE, eval=TRUE}
G_CK = Gest(childcare_ck_ppp, correction = "border")
plot(G_CK, xlim=c(0,500))
```

#### 5.1.1.2 Performing Complete Spatial Randomness Test
```{r echo=TRUE, eval=TRUE}
G_CK.csr <- envelope(childcare_ck_ppp, Gest, nsim = 999)
```

#### 5.1.1.3 Plot
```{r echo=TRUE, eval=TRUE}
plot(G_CK.csr)
```


### 5.1.2 Tampines planning area
#### 5.1.2.1 Computing G-function estimation
```{r echo=TRUE, eval=TRUE}
G_tm = Gest(childcare_tm_ppp, correction = "best")
plot(G_tm)
```

#### 5.1.2.2 Performing Complete Spatial Randomness Test
```{r echo=TRUE, eval=TRUE}
G_tm.csr <- envelope(childcare_tm_ppp, Gest, correction = "all", nsim = 999)
```

#### 5.1.3.3 Plot
```{r echo=TRUE, eval=TRUE}
plot(G_tm.csr)
```

## 5.2 Analysing Spatial Point Process Using F-Function
### 5.2.1 Choa Chu Kang planning area
#### 5.2.1.1 Computing F-function estimation
```{r echo=TRUE, eval=TRUE}
F_CK = Fest(childcare_ck_ppp)
plot(F_CK)
```

#### 5.2.1.2 Performing Complete Spatial Randomness Test
```{r echo=TRUE, eval=TRUE}
F_CK.csr <- envelope(childcare_ck_ppp, Fest, nsim = 999)
```

#### 5.2.1.3 Plot
```{r echo=TRUE, eval=TRUE}
plot(F_CK.csr)
```

### 5.2.2 Tampines planning area
#### 5.2.2.1 Computing F-function estimation
```{r echo=TRUE, eval=TRUE}
F_tm = Fest(childcare_tm_ppp, correction = "best")
plot(F_tm)
```

#### 5.2.2.2 Performing Complete Spatial Randomness Test
```{r echo=TRUE, eval=TRUE}
F_tm.csr <- envelope(childcare_tm_ppp, Fest, correction = "all", nsim = 999)
```

#### 5.2.2.3 Plot
```{r echo=TRUE, eval=TRUE}
plot(F_tm.csr)
```

## 5.3 Analysing Spatial Point Process Using K-Function
### 5.3.1 Choa Chu Kang planning area
#### 5.3.1.1 Computing K-function estimation
```{r echo=TRUE, eval=TRUE}
K_ck = Kest(childcare_ck_ppp, correction = "Ripley")
plot(K_ck, . -r ~ r, ylab= "K(d)-r", xlab = "d(m)")
```

#### 5.3.1.2 Performing Complete Spatial Randomness Test
```{r echo=TRUE, eval=TRUE}
K_ck.csr <- envelope(childcare_ck_ppp, Kest, nsim = 99, rank = 1, glocal=TRUE)
```

#### 5.3.1.3 Plot
```{r echo=TRUE, eval=TRUE}
plot(K_ck.csr, . - r ~ r, xlab="d", ylab="K(d)-r")
```

### 5.3.2 Tampines planning area
#### 5.3.2.1 Computing K-function estimation
```{r echo=TRUE, eval=TRUE}
K_tm = Kest(childcare_tm_ppp, correction = "Ripley")
plot(K_tm, . -r ~ r, 
     ylab= "K(d)-r", xlab = "d(m)", 
     xlim=c(0,1000))
```

#### 5.3.2.2 Performing Complete Spatial Randomness Test
```{r echo=TRUE, eval=TRUE}
K_tm.csr <- envelope(childcare_tm_ppp, Kest, nsim = 99, rank = 1, glocal=TRUE)

```

#### 5.3.2.3 Plot
```{r echo=TRUE, eval=TRUE}
plot(K_tm.csr, . - r ~ r, 
     xlab="d", ylab="K(d)-r", xlim=c(0,500))
```

## 5.4 Analysing Spatial Point Process Using L-Function
### 5.4.1 Choa Chu Kang planning area
#### 5.4.1.1 Computing L-function estimation
```{r echo=TRUE, eval=TRUE}
L_ck = Lest(childcare_ck_ppp, correction = "Ripley")
plot(L_ck, . -r ~ r, 
     ylab= "L(d)-r", xlab = "d(m)")
```

#### 5.4.1.2 Performing Complete Spatial Randomness Test
```{r echo=TRUE, eval=TRUE}
L_ck.csr <- envelope(childcare_ck_ppp, Lest, nsim = 99, rank = 1, glocal=TRUE)

```

#### 5.4.1.3 Plot
```{r echo=TRUE, eval=TRUE}
plot(L_ck.csr, . - r ~ r, xlab="d", ylab="L(d)-r")

```

### 5.4.2 Tampines planning area
#### 5.4.2.1 Computing L-function estimation
```{r echo=TRUE, eval=TRUE}
L_tm = Lest(childcare_tm_ppp, correction = "Ripley")
plot(L_tm, . -r ~ r, 
     ylab= "L(d)-r", xlab = "d(m)", 
     xlim=c(0,1000))
```

#### 5.4.2.2 Performing Complete Spatial Randomness Test
```{r echo=TRUE, eval=TRUE}
L_tm.csr <- envelope(childcare_tm_ppp, Lest, nsim = 99, rank = 1, glocal=TRUE)

```

#### 5.4.2.3 Plot
```{r echo=TRUE, eval=TRUE}
plot(L_tm.csr, . - r ~ r, 
     xlab="d", ylab="L(d)-r", xlim=c(0,500))
```
