---
title: "Hands-on Exercise 4"
description: |
  In this hands on exercise, I learn how to perform spatial point patterns analysis using spatstat package.
author:
  - name: Nor Aisyah
    url: https://www.linkedin.com/in/nor-aisyah/
date: 09-03-2021
output:
  distill::distill_article:
    self_contained: false
    toc: true
    toc_depth: 4
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```


# 1. Installing and Loading the R packages
```{r echo=TRUE, eval=TRUE}
packages = c('maptools', 'sf', 'raster','spatstat', 'tmap')
for (p in packages){
if(!require(p, character.only = T)){
install.packages(p)
}
library(p,character.only = T)
}
```

## 1.1 More information about the packages used
- **maptools**: Manipulate geographic data. 
  - Will be used to convert spatial objects into ppp format of spatstat
  
- **sf**: used for importing, managing, and processing **geospatial** data
  - specifically **vector-based** geospatial data
  
- **raster**: reads, writes, manipulates, analyses and model of **gridded** spatial data

- **spatstat**: contains useful functions for point pattern analysis. 
   - Will be used to perform **1st- and 2nd-order spatial point patterns analysis** and derive kernel density estimation (**KDE**) layer.
   
- **tmap**: provides functions for plotting cartographic **quality** *static* point patterns maps or *interactive* maps by using leaflet API.

### My own notes

- **ppp** is a point pattern object (of spatstat package)
- Difference between Spatial Data Types (Vector and Raster)
  - Raster data works with pixels
  - Vector data consists of coordinates
  - we can convert vector to raster, vice versa

# 2.Spatial Data Wrangling
## My own notes
- **Spatial vs Geospatial**: geospatial is of or pertaining to a geographic location, especially data while spatial is of or pertaining to space
- **st_transform**: takes a geometry (childcare_sf) and a spatial reference system identifier (3414) as input parameters and transforms the geometry to be represented in the given spatial reference system

```{r echo=TRUE, eval=TRUE}
childcare_sf <- st_read("data/child-care-services-geojson.geojson") 
st_crs(childcare_sf)
```

# 2.1 Importing the spatial data (import 3 geospatial datasets into R)
```{r echo=TRUE, eval=TRUE}
childcare_sf <- st_read("data/child-care-services-geojson.geojson") %>%
  st_transform(crs = 3414)
sg_sf <- st_read(dsn = "data", layer="CostalOutline")
mpsz_sf <- st_read(dsn = "data", 
                layer = "MP14_SUBZONE_WEB_PL")
```

** NOTE: Looking at the Projected CRS, we can see that both mpsz_sf and sg_sf are SVY21 but only childcare_sf is WGS 84. 

### My own notes
- EPSG: A particular CRS can be referenced by its EPSG code. The EPSG is a structured dataset of CRS and Coordinate Transformations. 
  - EPSG 4326 uses a coordinate system the same as a GLOBE (curved surface). 
  - EPSG 3857 uses a coordinate system the same as a MAP (flat surface).
  - EPSG 3414 coordinate system for Singapore - onshore and offshore
- Projected coordinate Systems: coordinate systems that are localized to minimize visual distortion in a particular region
- WGS84 is the defined coordinate system for GeoJSON, as longitude and latitude in decimal degrees.
- 4326 is the EPSG identifier of WGS84

# 2.2 Retrieve referencing system information of geospatial data using **st_crs**
```{r echo=TRUE, eval=TRUE}
st_crs(childcare_sf)
st_crs(mpsz_sf)
st_crs(sg_sf)
```

# 2.3 Assign correct crs to mpsz_sf and sg_sf simple feature data frames
```{r echo=TRUE, eval=TRUE}
mpsz_sf <- st_transform(mpsz_sf, crs= 3414)
sg_sf <- st_transform(sg_sf, crs= 3414)

st_crs(mpsz_sf)
st_crs(sg_sf)
```

# 2.4 Mapping the geospatial data sets
```{r echo=TRUE, eval=TRUE}
tm_shape(sg_sf) +
  tm_polygons() +
tm_shape(mpsz_sf) +
  tm_polygons() +
tm_shape(childcare_sf)+
  tm_dots()
```

### My own notes (Skip this part):
- **sg_sf**
  - must have **tm_polygon** if not there will be an error: no layer elements defined after tm_shape
  
```{r echo=TRUE, eval=TRUE}
tm_shape(sg_sf) +
  tm_polygons() 
```
   - *plot function*
   
```{r echo=TRUE, eval=TRUE}
plot(sg_sf)
```

- **mpsz_sf**
  - You can see that there is a difference between mpsz_sf and sg_sf Because the data is different:
  - **mpsz_sf** (MP14_SUBZONE_WEB_PL) is a polygon feature data providing information of URA 2014 Master Plan Planning Subzone boundary data while **sg_sf**(CostalOutline) is a polygon feature data showing the national boundary of Singapore. 
  
```{r echo=TRUE, eval=TRUE}
tm_shape(mpsz_sf) +
  tm_polygons() 
```

```{r echo=TRUE, eval=TRUE}
plot(mpsz_sf)
```

- **childcare_sf**
  - childcare_sf is a point feature data. That is why it doesn't make sense to plot the data as polygons. (see plot below) 
  - Hence, we used tm_dots instead to plot the data as points. 
  - childcare_sf (CHILDCARE) provides both location and attribute information of childcare centres in SG. 
  
```{r echo=TRUE, eval=TRUE}
plot(childcare_sf)
```
# 2.5 Creating a Pin Map

### My own notes
- tmap is using **leaflet for R** API (open-source JavaScript libraries for interactive maps). 
- this interactive pin map is it allows us to:
  - navigate and zoom around the map freely. 
  - can also query information of each simple feature (i.e. the point) by clicking of them.
  - can also change the background of the internet map layer. 
- NOTE: **MUST** remember to **switch back to plot mode** after the interactive map
  - since each interactive mode will consume a connection
  - should **AVOID** displaying excessive no. of interactive maps (i.e. **not more than 10**) in 1 RMarkdown document
- There are multiple map types:
  - 1. **Pin maps** mark specific locations.
  - 2. **Region maps** group data by country or state.
  - 3. **Grid maps** distribute a large number of points over a specified area.

```{r echo=TRUE, eval=TRUE}
tmap_mode('view')
tm_shape(childcare_sf)+
  tm_dots()
```

Here we are switching back to plot mode:

```{r echo=TRUE, eval=TRUE}
tmap_mode('plot')
```

# 3. Geospatial Data wrangling
## 3.1 Converting sf data frames to sp’s Spatial* class
```{r echo=TRUE, eval=TRUE}
childcare <- as_Spatial(childcare_sf)
mpsz <- as_Spatial(mpsz_sf)
sg <- as_Spatial(sg_sf)
```

### My own notes
- See the difference between sp and sf (childcare)

```{r echo=TRUE, eval=TRUE}
head(childcare_sf)
head(childcare)

plot(childcare_sf)
plot(childcare)
```

- See the difference between sp and sf (mpsz)

```{r echo=TRUE, eval=TRUE}
head(mpsz_sf)
head(mpsz)

plot(mpsz_sf)
plot(mpsz)
```

- See the difference between sp and sf (sg)

```{r echo=TRUE, eval=TRUE}
head(sg_sf)
head(sg)

plot(sg_sf)
plot(sg)
```

### 3.1.1 Display information of 3 Spatial* classes
- Can see the difference in the class (no longer sf)

```{r echo=TRUE, eval=TRUE}
childcare
mpsz 
sg 
```


## 3.2 Converting the Spatial* class into generic sp format
- spatstat requires the analytical data in ppp object form. 
- THUS, the *only way* to do this is to **convert Spatial classes* into Spatial object first** then convert it to ppp object. 

```{r echo=TRUE, eval=TRUE}
childcare_sp <- as(childcare, "SpatialPoints")
sg_sp <- as(sg, "SpatialPolygons")
```

### My own notes: Spatial* classes vs generic sp object**
- You can see that the previous SpatialPolygonsDataFrame class has now changed to the respective Spatial objects (points/polygons)
- The points in a SpatialPoints object may be associated with a row of attributes to create a SpatialPointsDataFrame object
 
## 3.3 Converting the generic sp format into spatstat’s ppp format
```{r echo=TRUE, eval=TRUE}
childcare_ppp <- as(childcare_sp, "ppp")
childcare_ppp
```

### 3.3.1 Plot childcare_ppp to see difference
```{r echo=TRUE, eval=TRUE}
plot(childcare_sf)
plot(childcare)
plot(childcare_ppp)
```

### 3.3.2 See summary statistics 
- You can see the **warning message about duplicates** here
- spatial point patterns processes is based largely on the assumption that process are simple, that is, that the points cannot be coincident
- So it is a must for us to remove duplicates

```{r echo=TRUE, eval=TRUE}
summary(childcare_sf)

summary(childcare)

summary(childcare_ppp)
```

## 3.4  Handling duplicated points

### 3.4.1 Check for duplicates
```{r echo=TRUE, eval=TRUE}
any(duplicated(childcare_ppp))
```

### 3.4.2 Count number of co-indicence point
```{r echo=TRUE, eval=TRUE}
multiplicity(childcare_ppp)
```

### 3.4.3 See locations that have more than 1 point event
- The output will show the total number of duplicated point events

```{r echo=TRUE, eval=TRUE}
sum(multiplicity(childcare_ppp) > 1)
```

### 3.4.4 View locations of duplicate point events
```{r echo=TRUE, eval=TRUE}
tmap_mode('view')
tm_shape(childcare) +
  tm_dots(alpha=0.4, 
          size=0.05)
tmap_mode('plot')

```

### 3.4.5 Overcome duplicates problem
3 ways:
- 1. **Delete** the duplicates (result in loss of useful point events)
- 2. Use **jittering** approach: Add a small perturbation to the duplicate points so that they do not occupy the exact same space
- 3. Make each point **unique** and then attach the duplicates of the points to the patterns as marks, as attributes of the points

#### 3.4.5.1 Jittering (resolve duplicates issue)
```{r echo=TRUE, eval=TRUE}
childcare_ppp_jit <- rjitter(childcare_ppp, 
                             retry=TRUE, 
                             nsim=1, 
                             drop=TRUE)
```


#### 3.4.5.2 Check if any dusplicated point in this geospatial data
```{r echo=TRUE, eval=TRUE}
any(duplicated(childcare_ppp_jit))
```

## 3.5 Create **owin** object (convert sp to owin)
- When analysing spatial point patterns, it is a good practice to **confine the analysis with a geographical area** like SG boundary.
- In spatstat, an object called **owin is specially designed to represent this polygonal **
- We can create this object by converting sg SpatialPolygon object into owin object of spatstat

```{r echo=TRUE, eval=TRUE}
sg_owin <- as(sg_sp, "owin")
plot(sg_sp)
plot(sg_owin)
```

```{r echo=TRUE, eval=TRUE}
summary(sg_owin)
```

### 3.5.1 Combining point events object and owin object
- extract childcare events that are located within Singapore 

```{r echo=TRUE, eval=TRUE}
childcareSG_ppp = childcare_ppp[sg_owin]
childcareSG_ppp
```

```{r echo=TRUE, eval=TRUE}
summary(childcareSG_ppp)
```

# First-order Spatial Point Patterns Analysis
**In point pattern analysis, Spatial point data that you have must be the whole population, cannot be a sample**
Describing the spatial pattern:
- In order to confirm the observed pattern indeed show a cluster and not randomly distribute, need to perform statistical test.
- That is why we need to perform SPA. 
- SPA don't allow you to analyse the height of buildings since it is studying Euclidean space
- SPA all geo data should be in Projected CRS and not geographic since geographic is in decimal degree
- 1st order - find out whether a particular Spatial point pattern is randomly distributed or is there a sign of clustering.
  - Assumptions are due to the underlying properties
  - If it is a crime - thefts, then you see whether where the rich and supermarkets at
  - if car collision - then underlying reason might be due to the blind spots or poor planning of roads
- 2nd order - locations of child care center tend to cluster together bc that is where they tend to enjoy g? economics
  - if you find McDonald's, chances are you can find KFC nearby. 
  - Find out whether the spatial patterns that we observed is due to interaction effect between all the spatial points.

For KDE, 
- Certain crimes can be either sparse or localized. For eg, drugs distribution. In UK, common distribution places are either at nightclubs or illegal drugstores. So take this into consideration before choosing quartic and normal. 
- in SG, parents tend to send their kids to kindergarten nearer to home or work locations.So this resembles quartic. 
- For sec schools, parents tend to look for schools that are better. So people are willing travel slightly longer and this resembles Gaussian.
- Must control or fixed the number of points you can catch for Adaptive Bandwidth. 
- When to use fixed/adaptive?
  - Depends on spatial configuration
  - In SG context, childcare you cannot use fixed since in town vs out town there are a difference in the no. of buildings like retail malls etc. Hence, must use adaptive bandwidth.
  - If we are only focusing on Punggol area, then it makes sense to use fixed bandwith because it tends to be more concentrated.

# 4. First-order Spatial Point Patterns Analysis

## 4.1 Kernel Density Estimation

### My own notes
- Kernel density estimation involves applying a function (known as a “kernel”) to each data point, which averages the location of that point with respect to the location of other data points.
- Kernel density estimation maps are very popular among crime analysts.
- The areas identified as hotspots by KDE (using historical data) tend to be the ones that better identify the areas that will have high levels of crime in the future.
- uses a statistical technique (kernel density estimation) to generate a smooth continuous surface aiming to represent the density or volume of crimes across the target area
- smoothing kernel used is *gaussian*, which is the default.
- key argument to pass to the density method for point pattern objects is **sigma=**, which determines the bandwidth of the kernel. 
In spatstat the functions bw.diggle(), bw.ppl(), and bw.scott() can be used to estimate the bandwidth according to difference methods

```{r echo=TRUE, eval=TRUE}
bw.diggle(childcareSG_ppp)
bw.ppl(childcareSG_ppp)
bw.scott(childcareSG_ppp)

```

### 4.1.1 Computing kernel density estimation using automatic bandwidth selection method
```{r echo=TRUE, eval=TRUE}
kde_childcareSG_bw <- density(childcareSG_ppp,
                              sigma=bw.diggle,
                              edge=TRUE,
                            kernel="gaussian") 
```

```{r echo=TRUE, eval=TRUE}
plot(kde_childcareSG_bw)
```

- density values of the output range from 0 to 0.000035 which is way too small to comprehend. 
- This is because the default unit of measurement of svy21 is in meter. 
- As a result, the density values computed is in “number of points per square meter”.
- HENCE, we need to rescale from meter to kilometer later

### 4.1.2 Retrieve the bandwidth used to compute the kde layer
```{r echo=TRUE, eval=TRUE}
bw <- bw.diggle(childcareSG_ppp)
bw
```

### 4.1.2 Rescalling KDE using **rescale()**
- To convert the unit of measurement from meter to kilometer.

```{r echo=TRUE, eval=TRUE}
childcareSG_ppp.km <- rescale(childcareSG_ppp, 1000, "km")
```

### 4.1.3 Plotkde map
```{r echo=TRUE, eval=TRUE}
kde_childcareSG.bw <- density(childcareSG_ppp.km, sigma=bw.diggle, edge=TRUE, kernel="gaussian")
plot(kde_childcareSG.bw)
```

** notice the **change in the legend**!

### 4.1.3 Working with different automatic bandwidth methods
```{r echo=TRUE, eval=TRUE}
 bw.CvL(childcareSG_ppp.km)
```

```{r echo=TRUE, eval=TRUE}
bw.scott(childcareSG_ppp.km)
```

```{r echo=TRUE, eval=TRUE}
bw.ppl(childcareSG_ppp.km)
```

```{r echo=TRUE, eval=TRUE}
bw.diggle(childcareSG_ppp.km)
```

#### 4.1.3.1 Compare output of using bw.diggle and bw.ppl methods
```{r echo=TRUE, eval=TRUE}
kde_childcareSG.ppl <- density(childcareSG_ppp.km, 
                               sigma=bw.ppl, 
                               edge=TRUE,
                               kernel="gaussian")
par(mfrow=c(1,2))
plot(kde_childcareSG.bw, main = "bw.diggle")
plot(kde_childcareSG.ppl, main = "bw.ppl")
```


### 4.1.4 Working with different kernel methods
- As mentioned earlier, default  kernel method is gaussian
- There are others like: Epanechnikov, Quartic and Dic

#### My own notes
- Not much difference can be seen: 
  - Looks like Gaussian is the clearest, Disc looks pixelated
  
```{r echo=TRUE, eval=TRUE}
par(mfrow=c(2,2))
plot(density(childcareSG_ppp.km, 
             sigma=bw.ppl, 
             edge=TRUE, 
             kernel="gaussian"), 
     main="Gaussian")
plot(density(childcareSG_ppp.km, 
             sigma=bw.ppl, 
             edge=TRUE, 
             kernel="epanechnikov"), 
     main="Epanechnikov")
plot(density(childcareSG_ppp.km, 
             sigma=bw.ppl, 
             edge=TRUE, 
             kernel="quartic"), 
     main="Quartic")
plot(density(childcareSG_ppp.km, 
             sigma=bw.ppl, 
             edge=TRUE, 
             kernel="disc"), 
     main="Disc")
```

### 4.1.5 Fixed and Adaptive KDE

#### 4.1.5.1 Computing KDE by using **fixed** bandwidth
- Compute a KDE layer by defining a bandwidth of 600 meter
- **NOTE**: Sigma value used is 0.6 since unit of measurement of childcareSG_ppp.km object is in kilometer, hence the 600m is 0.6km
- Fixed bandwidth method is **very sensitive to highly skewed distribution** of spatial point patterns over geographical units for example urban versus rural

```{r echo=TRUE, eval=TRUE}
kde_childcareSG_600 <- density(childcareSG_ppp.km, sigma=0.6, edge=TRUE, kernel="gaussian")
plot(kde_childcareSG_600)
```

#### 4.1.5.2 Computing KDE by using adaptive bandwidth
- One way to overcome **highly skewed distribution** is by using adaptive bandwidth

```{r echo=TRUE, eval=TRUE}
kde_childcareSG_adaptive <- adaptive.density(childcareSG_ppp.km, method="kernel")
plot(kde_childcareSG_adaptive)
```

#### 4.1.5.3 Compare fixed and adaptive kernel density estimation outputs
- Noticed the difference in the legend and colours in the map

```{r echo=TRUE, eval=TRUE}
par(mfrow=c(1,2))
plot(kde_childcareSG.bw, main = "Fixed bandwidth")
plot(kde_childcareSG_adaptive, main = "Adaptive bandwidth")
```

### 4.1.6 Converting KDE output into grid object
- Reason for converting: The result is the same, we just convert it so that it is *suitable for mapping purposes*

```{r echo=TRUE, eval=TRUE}
gridded_kde_childcareSG_bw <- as.SpatialGridDataFrame.im(kde_childcareSG.bw)
spplot(gridded_kde_childcareSG_bw)
```

#### 4.1.6.1 Converting gridded output into raster
- made up of pixels (also referred to as grid cells)
- Rasters often look pixelated because each pixel has its own value or class
- Notice that the crs property is NA.

```{r echo=TRUE, eval=TRUE}
kde_childcareSG_bw_raster <- raster(gridded_kde_childcareSG_bw)
kde_childcareSG_bw_raster
```

#### 4.1.6.2 Assigning projection systems
- Because the above output show NA for crs

```{r echo=TRUE, eval=TRUE}
projection(kde_childcareSG_bw_raster) <- CRS("+init=EPSG:3414")
kde_childcareSG_bw_raster
```

### 4.1.7 Visualising the output in tmap
- raster values are encoded explicitly onto the raster pixel using the values in “v”" field in the code below

```{r echo=TRUE, eval=TRUE}
tm_shape(kde_childcareSG_bw_raster) + 
  tm_raster("v") +
  tm_layout(legend.position = c("right", "bottom"), frame = FALSE)
```

### 4.1.8 Comparing Spatial Point Patterns using KDE
#### 4.1.8.1 Extracting study area
- Extract the target planning areas first before plotting

```{r echo=TRUE, eval=TRUE}
pg = mpsz[mpsz@data$PLN_AREA_N == "PUNGGOL",]
tm = mpsz[mpsz@data$PLN_AREA_N == "TAMPINES",]
ck = mpsz[mpsz@data$PLN_AREA_N == "CHOA CHU KANG",]
jw = mpsz[mpsz@data$PLN_AREA_N == "JURONG WEST",]

par(mfrow=c(2,2))
plot(pg, main = "Ponggol")
plot(tm, main = "Tampines")
plot(ck, main = "Choa Chu Kang")
plot(jw, main = "Jurong West")
```

#### 4.1.8.2 Converting the spatial point data frame into generic sp format
```{r echo=TRUE, eval=TRUE}
pg_sp = as(pg, "SpatialPolygons")
tm_sp = as(tm, "SpatialPolygons")
ck_sp = as(ck, "SpatialPolygons")
jw_sp = as(jw, "SpatialPolygons")
```

#### 4.1.8.3 Creating owin object
```{r echo=TRUE, eval=TRUE}
pg_owin = as(pg_sp, "owin")
tm_owin = as(tm_sp, "owin")
ck_owin = as(ck_sp, "owin")
jw_owin = as(jw_sp, "owin")
```

#### 4.1.8.4 Combining childcare points and the study area
- Extract childcare that is within the specific region to do our analysis later on

```{r echo=TRUE, eval=TRUE}
childcare_pg_ppp = childcare_ppp_jit[pg_owin]
childcare_tm_ppp = childcare_ppp_jit[tm_owin]
childcare_ck_ppp = childcare_ppp_jit[ck_owin]
childcare_jw_ppp = childcare_ppp_jit[jw_owin]
```

- Transform the unit of measurement from meter to kilometer.

```{r echo=TRUE, eval=TRUE}
childcare_pg_ppp.km = rescale(childcare_pg_ppp, 1000, "km")
childcare_tm_ppp.km = rescale(childcare_tm_ppp, 1000, "km")
childcare_ck_ppp.km = rescale(childcare_ck_ppp, 1000, "km")
childcare_jw_ppp.km = rescale(childcare_jw_ppp, 1000, "km")
```

- Plot these four study areas and the locations of the childcare centres.

```{r echo=TRUE, eval=TRUE}
par(mfrow=c(2,2))
plot(childcare_pg_ppp.km, main="Punggol")
plot(childcare_tm_ppp.km, main="Tampines")
plot(childcare_ck_ppp.km, main="Choa Chu Kang")
plot(childcare_jw_ppp.km, main="Jurong West")
```

#### 4.1.8.5 Computing KDE
```{r echo=TRUE, eval=TRUE}
par(mfrow=c(2,2))
plot(density(childcare_pg_ppp.km, 
             sigma=bw.diggle, 
             edge=TRUE, 
             kernel="gaussian"),
     main="Punggol")
plot(density(childcare_tm_ppp.km, 
             sigma=bw.diggle, 
             edge=TRUE, 
             kernel="gaussian"),
     main="Tempines")
plot(density(childcare_ck_ppp.km, 
             sigma=bw.diggle, 
             edge=TRUE, 
             kernel="gaussian"),
     main="Choa Chu Kang")
plot(density(childcare_jw_ppp.km, 
             sigma=bw.diggle, 
             edge=TRUE, 
             kernel="gaussian"),
     main="JUrong West")
```

#### 4.1.8.6 Computing fixed bandwidth KDE
```{r echo=TRUE, eval=TRUE}
par(mfrow=c(2,2))
plot(density(childcare_ck_ppp.km, 
             sigma=0.25, 
             edge=TRUE, 
             kernel="gaussian"),
     main="Chou Chu Kang")
plot(density(childcare_jw_ppp.km, 
             sigma=0.25, 
             edge=TRUE, 
             kernel="gaussian"),
     main="JUrong West")
plot(density(childcare_pg_ppp.km, 
             sigma=0.25, 
             edge=TRUE, 
             kernel="gaussian"),
     main="Punggol")
plot(density(childcare_tm_ppp.km, 
             sigma=0.25, 
             edge=TRUE, 
             kernel="gaussian"),
     main="Tampines")
```

### 4.1.9 Nearest Neighbour Analysis
- measures the spread or distribution of something over a geographical space
- The test hypotheses are:
  - Ho = The distribution of childcare services are randomly distributed.
  - H1= The distribution of childcare services are not randomly distributed.
  - The 95% confident interval will be used.

#### 4.1.9.1 Testing spatial point patterns using Clark and Evans Test
```{r echo=TRUE, eval=TRUE}
clarkevans.test(childcareSG_ppp,
                correction="none",
                clipregion="sg_owin",
                alternative=c("clustered"),
                nsim=99)
```

#### 4.1.9.2 Clark and Evans Test: Choa Chu Kang planning area
```{r echo=TRUE, eval=TRUE}
clarkevans.test(childcare_ck_ppp,
                correction="none",
                clipregion=NULL,
                alternative=c("two.sided"),
                nsim=999)
```

#### 4.1.9.3 Clark and Evans Test: Tampines planning area
```{r echo=TRUE, eval=TRUE}
clarkevans.test(childcare_tm_ppp,
                correction="none",
                clipregion=NULL,
                alternative=c("two.sided"),
                nsim=999)
```


# 5. Second-order Spatial Point Patterns Analysis
## 5.1 Analysing Spatial Point Process Using G-Function (Gest nearest neighbour distribution function)
### 5.1.1 Choa Chu Kang planning area
#### 5.1.1.1 Computing G-function estimation
```{r echo=TRUE, eval=TRUE}
G_CK = Gest(childcare_ck_ppp, correction = "border")
plot(G_CK, xlim=c(0,500))
```

#### 5.1.1.2 Performing Complete Spatial Randomness Test
- To confirm the observed spatial patterns above, a hypothesis test will be conducted. The hypothesis and test are as follows:
- Ho = The distribution of childcare services at Choa Chu Kang are randomly distributed.
- H1= The distribution of childcare services at Choa Chu Kang are not randomly distributed.
- The null hypothesis will be rejected if p-value is smaller than alpha value of 0.001.

** Monte Carlo
- rely on repeated random sampling to obtain numerical results
- use randomness to solve problems that might be deterministic in principle
- probability of different outcomes in a process that cannot easily be predicted due to the intervention of random variables

```{r echo=TRUE, eval=TRUE}
G_CK.csr <- envelope(childcare_ck_ppp, Gest, nsim = 999)
```

#### 5.1.1.3 Plot
```{r echo=TRUE, eval=TRUE}
plot(G_CK.csr)
```

### 5.1.2 Tampines planning area
#### 5.1.2.1 Computing G-function estimation
```{r echo=TRUE, eval=TRUE}
G_tm = Gest(childcare_tm_ppp, correction = "best")
plot(G_tm)
```

#### 5.1.2.2 Performing Complete Spatial Randomness Test
```{r echo=TRUE, eval=TRUE}
G_tm.csr <- envelope(childcare_tm_ppp, Gest, correction = "all", nsim = 999)
```

#### 5.1.3.3 Plot
```{r echo=TRUE, eval=TRUE}
plot(G_tm.csr)
```

## 5.2 Analysing Spatial Point Process Using F-Function (Fest empty space function F)
### 5.2.1 Choa Chu Kang planning area
#### 5.2.1.1 Computing F-function estimation
```{r echo=TRUE, eval=TRUE}
F_CK = Fest(childcare_ck_ppp)
plot(F_CK)
```

#### 5.2.1.2 Performing Complete Spatial Randomness Test
```{r echo=TRUE, eval=TRUE}
F_CK.csr <- envelope(childcare_ck_ppp, Fest, nsim = 999)
```

#### 5.2.1.3 Plot
```{r echo=TRUE, eval=TRUE}
plot(F_CK.csr)
```

### 5.2.2 Tampines planning area
#### 5.2.2.1 Computing F-function estimation
```{r echo=TRUE, eval=TRUE}
F_tm = Fest(childcare_tm_ppp, correction = "best")
plot(F_tm)
```

#### 5.2.2.2 Performing Complete Spatial Randomness Test
```{r echo=TRUE, eval=TRUE}
F_tm.csr <- envelope(childcare_tm_ppp, Fest, correction = "all", nsim = 999)
```

#### 5.2.2.3 Plot
```{r echo=TRUE, eval=TRUE}
plot(F_tm.csr)
```

## 5.3 Analysing Spatial Point Process Using K-Function (Kest Ripley’s K-function)
### 5.3.1 Choa Chu Kang planning area
#### 5.3.1.1 Computing K-function estimation
```{r echo=TRUE, eval=TRUE}
K_ck = Kest(childcare_ck_ppp, correction = "Ripley")
plot(K_ck, . -r ~ r, ylab= "K(d)-r", xlab = "d(m)")
```

#### 5.3.1.2 Performing Complete Spatial Randomness Test
```{r echo=TRUE, eval=TRUE}
K_ck.csr <- envelope(childcare_ck_ppp, Kest, nsim = 99, rank = 1, glocal=TRUE)
```

#### 5.3.1.3 Plot
```{r echo=TRUE, eval=TRUE}
plot(K_ck.csr, . - r ~ r, xlab="d", ylab="K(d)-r")
```

### 5.3.2 Tampines planning area
#### 5.3.2.1 Computing K-function estimation
```{r echo=TRUE, eval=TRUE}
K_tm = Kest(childcare_tm_ppp, correction = "Ripley")
plot(K_tm, . -r ~ r, 
     ylab= "K(d)-r", xlab = "d(m)", 
     xlim=c(0,1000))
```

#### 5.3.2.2 Performing Complete Spatial Randomness Test
```{r echo=TRUE, eval=TRUE}
K_tm.csr <- envelope(childcare_tm_ppp, Kest, nsim = 99, rank = 1, glocal=TRUE)

```

#### 5.3.2.3 Plot
```{r echo=TRUE, eval=TRUE}
plot(K_tm.csr, . - r ~ r, 
     xlab="d", ylab="K(d)-r", xlim=c(0,500))
```

## 5.4 Analysing Spatial Point Process Using L-Function
### 5.4.1 Choa Chu Kang planning area
#### 5.4.1.1 Computing L-function estimation
```{r echo=TRUE, eval=TRUE}
L_ck = Lest(childcare_ck_ppp, correction = "Ripley")
plot(L_ck, . -r ~ r, 
     ylab= "L(d)-r", xlab = "d(m)")
```

#### 5.4.1.2 Performing Complete Spatial Randomness Test
```{r echo=TRUE, eval=TRUE}
L_ck.csr <- envelope(childcare_ck_ppp, Lest, nsim = 99, rank = 1, glocal=TRUE)

```

#### 5.4.1.3 Plot
```{r echo=TRUE, eval=TRUE}
plot(L_ck.csr, . - r ~ r, xlab="d", ylab="L(d)-r")

```

### 5.4.2 Tampines planning area
#### 5.4.2.1 Computing L-function estimation
```{r echo=TRUE, eval=TRUE}
L_tm = Lest(childcare_tm_ppp, correction = "Ripley")
plot(L_tm, . -r ~ r, 
     ylab= "L(d)-r", xlab = "d(m)", 
     xlim=c(0,1000))
```

#### 5.4.2.2 Performing Complete Spatial Randomness Test
```{r echo=TRUE, eval=TRUE}
L_tm.csr <- envelope(childcare_tm_ppp, Lest, nsim = 99, rank = 1, glocal=TRUE)

```

#### 5.4.2.3 Plot
```{r echo=TRUE, eval=TRUE}
plot(L_tm.csr, . - r ~ r, 
     xlab="d", ylab="L(d)-r", xlim=c(0,500))
```
