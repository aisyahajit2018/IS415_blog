---
title: "Hands-on Exercise 5b"
description: |
  In this hands-on exercise, I will gain hands-on experience on using appropriate R functions to analyse marks spatial point events.
author:
  - name: Nor Aisyah
    url: https://www.linkedin.com/in/nor-aisyah/
date: 09-26-2021
output:
  distill::distill_article:
    self_contained: false
    toc: true
    toc_depth: 4
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```

# 1. Overview

- As discussed in class, a **point pattern** dataset contains:

  - a complete enumeration of events (i.e., objects of interest) occurring in a defined study region. 
- These events could represent anything with a measurable location including traffic accidents, crime occurrences, social service location, business establishment locations, etc. 
- In addition to locational information, each event could have an associated continuous (e.g., number of students, volume of sales) or categorical measurement (e.g., type of schools, operators of the fast food chains). 
- The **measurements** are called **marks** and 
- the **events** with marks are called a **marked point pattern**.

Marked point patterns have:  

- **first-order properties**, which are related to the *intensity* (i.e., density) of events and associated marks across the study region, and 
- **second-order properties**, which are related to the *spatial dependence* (i.e., spatial arrangement) of the events and associated marks across the study area.


The specific question we would like to answer is:

- Are the locations of childcare centre by different business groups (i.e. NT, PT, RC, ST) spatial independent?
- If the answer is NO, are there any phenomena of attraction or repulsion?


# 2. The dataset

To provide answer to the questions above, 2 data sets will be used:

- Childcare centre: The original data is in KML format.  It has been converted into ESRI shapefile format. 
- URA Master Plan Subzone 2014: It is in ESRI shapefile format.

Both data sets were downloaded from Data.gov.

# 3. Installing and Loading the R packages 

For the purpose of this study, five R packages will be used.  They are:

- **rgdal** for importing geospatial data in GIS file format such as shapefile into R and save them as Spatial*DataFrame,
- **maptools** for converting Spatial* object into ppp object,
- **raster** for handling raster data in R,
- **spatstat** for performing Spatial Point Patterns Analysis such as kcross, Lcross, etc., and
- **tmap** for producing cartographic quality thematic maps.

```{r echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
packages = c('rgdal', 'maptools', 'raster','spatstat', 'tmap')
for (p in packages){
if(!require(p, character.only = T)){
install.packages(p)
}
library(p,character.only = T)
}
```

# 4. Importing the Geospatial Data
## 4.1 Import geospatial data using **readOGR()** of **rgdal** 
The code chunk below uses **readOGR()** of **rgdal** package to import both geospatial data files (i.e. shapefile) into R:  

```{r echo=TRUE, eval=TRUE}
childcare <- readOGR(dsn = "data/geospatial", layer="CHILDCARE")
mpsz = readOGR(dsn = "data/geospatial", layer="MP14_SUBZONE_WEB_PL")
```

- **NOTE**: Since, *readOGR()* of **rgdal** package is used, the output R objects will be in SpatialPointsDataframe and SpatialPolygonsDataframe classes respectively. 

## 4.2 Check data type and convert marked field to factor

Next *str()* of Base R will be used to check the data type of `childcare` SpatialPointsDataFrame.  This is necessary because the **marked** field must be in **factor** data type if its values are categorical.

```{r echo=TRUE, eval=TRUE}
str(childcare)
```

- The output above shows that `Type` field is in character data type and not in factor data type as required by spatstat package. 
- Hence, the code chunk below will be used to convert `Type` field to factor data type.

```{r echo=TRUE, eval=TRUE}
childcare@data$Type <- as.factor(childcare@data$Type)
```

DIY: Using the skill you learned from previous step, check to ensure that `Type` field is in **factor** data type now:

```{r echo=TRUE, eval=TRUE}
str(childcare)
```

## 4.3 Mapping the geospatial layers

Next, let us take a quick look at the distribution of the geospatial data.  In the code chunk below, mapping functions of **tmap** package is used.  `tmap_mode("view")` is used to plot an interactive map by using [leaflet](https://leafletjs.com/) api. 

### 4.3.1 Mapping using tmap_mode("view")
```{r echo=TRUE, eval=TRUE}
tmap_mode("view")
tm_shape(mpsz) +
  tm_borders(alpha = 0.5) +
  tmap_options(check.and.fix = TRUE) +
tm_shape(childcare) +
  tm_dots(col = 'Type', size = 0.02)
tmap_mode("plot")
```

### 4.3.2 Mapping using *tm_facets()* of **tmap**

Alternatively, we can use the code chunk below to create four small point maps by using *tm_facets()* of **tmap** pckage.

```{r eval=TRUE, fig.width=12, fig.height=8}
tm_shape(mpsz) +
  tm_borders(alpha = 0.5) +
tm_shape(childcare) +
  tm_dots(col = 'Type', 
          size = 0.5) +
tm_facets(by="Type")
```

# 5. Spatial Data Wrangling

## 5.1 Converting the SpatialPointsDataFrame into ppp format

- The code chunk below uses *as.(x, "ppp")* or *as.ppp(x)* of **maptools** package to convert an object *x* of class SpatialPointsDataFrame to a spatial point pattern in **spatstat**. 
- In this conversion, the additional field in *x* data frame will become the marks of the point pattern z.

```{r echo=TRUE, eval=TRUE}
childcare_ppp <- as(childcare, "ppp")
plot(childcare_ppp)
```

Figure above reveals that there are 4 sub-types in the marks list.  They are: **NT, PT, RC and ST.**

## 5.2 Examine the summary statistics spatial object

To examine the summary statistics of this spatial object, summary() of Base R will be used as shown in the code chunk below.

```{r echo=TRUE, eval=TRUE}
summary(childcare_ppp)
```

The report above reveals that: 

- PT is the largest childcare operator in Singapore with a market share of **63%**.  
- This is followed by ST, RC and NT.
- It is also important to node that the spatial point object contains duplicated points.  
- The quality of our analysis will be compromised if we failed to resolve this data issue.

## 5.3 Avoiding duplicated spatial point event by using jittering method

The code chunk below resolves the duplicated spatial point events issue by using the jittering approach.

```{r echo=TRUE, eval=TRUE}
childcare_ppp_jit <- rjitter(childcare_ppp, retry=TRUE, nsim=1, drop=TRUE)
```

Let us check the output to ensure that there is no more duplicated spatial point events in the data.

```{r echo=TRUE, eval=TRUE}
any(duplicated(childcare_ppp_jit))
```

The output shows that the duplicated points issue has been resolved.

## 5.4 Creating ***owin***

When analysing spatial point patterns, it is a good practice to **confine the analysis within a geographical area like Singapore boundary**.  
- In **spatstat**, an object called ***owin*** is specially designed to represent this polygonal region.
- Before we going ahead to create owin object, however, it is important to understand the geography of the study area.  
- Our country are constrained by natural such as central water catchment and western reserved area and strategic location such as airports. 
- In view of this, it is wiser for us to **narrow down the study area by more appropriate geographical area such as by planning area**.

### 5.4.1 Extracting study area

For the purpose of this study, we will focus of Jurong West planning area. (**Note**: This is based on context!)

The code chunk below will be used to extract the target planning areas.

```{r echo=TRUE, eval=TRUE}
jw = mpsz[mpsz@data$PLN_AREA_N == "JURONG WEST",]
plot(jw, main = "Jurong West")
```

### 5.4.2 Converting the spatial point data frame into generic sp format

Next, we will convert these SpatialPolygonsDataFrame layers into generic spatialpolygons layers by using *as.SpatialPolygons.tess(x)* of **maptools** package. 

```{r echo=TRUE, eval=TRUE}
jw_sp = as(jw, "SpatialPolygons")
str(jw_sp)
```

**Best Practice**: It is always recommended to review the structure of the output object by using either the UI of RStudio or *str()* function.

### 5.4.3 Creating ***owin*** object

Now, we will convert these SpatialPolygons objects into owin objects that is required by **spatstat**:

```{r echo=TRUE, eval=TRUE}
jw_owin = as(jw_sp, "owin")
str(jw_owin)
```

### 5.4.4 Combining childcare points and the study area

By using the code chunk below, we are able to extract childcare that is within the specific region to do our analysis later on.

```{r echo=TRUE, eval=TRUE}
childcare_jw_ppp = childcare_ppp_jit[jw_owin]
```

Next, *summary()* is used to reveal the data object as shown in the code chunk below.

```{r echo=TRUE, eval=TRUE}
summary(childcare_jw_ppp)
```

DIY: By referring to previous discussion, describe the content of the output.

From our summary report above: 

- PT is again the largest childcare operator in Jurong West area this time, with a market share of 50%.
- This market share of 50% is still smaller than their national market share of 63%. 
- Looking at the frequency, the PT operator had 1183 childcare centres in Singapore but only 58 in Jurong West. 
- Thus, we can assume that their presence in Jurong West is smaller than other areas.

## 5.5 Plotting childcare points and the study area

Lastly, we will plot the combined childcare point and the study area to ensure that the spatial point events are indeed contained within the study area.

```{r fig.width=12, fig.height=12}
plot(childcare_jw_ppp)
```

# 6. Analysing Marked Point Patterns
## 6.1 First-order Spatial Point Patterns Analysis
### 6.1.1 Plot density map

In the code chunk below:  

- *density()* of **spatstat** package is used to compute the kernel density objects.  
- Then, **plot()** is used to plot the output kernel density objects derived.  
- Instead of writing them in two seperate lines, the code chunk below shows how they can be combined into one single line code chunk.  

```{r fig.width=12, fig.height=12}
plot(density(split(rescale(childcare_jw_ppp, 1000))))
```

Question: Can you recall what is the purpose of rescale() and why it is used in our case?

- To convert the unit of measurement from meter to kilometer.
- Why we have to rescale? Since svy21 projection system is in meter, the computed density values is very small i.e. 0.0000005.



DIY: What observations can you draw from the figure above?

- NT’s childcare centres are mostly clustered in the Central and East region indicated by the higher and brighter shade of yellow in the middle and right of the plot.  
- PT’s childcare centres are found in the West, East and Southeast region of Jurong West area with a higher density found in the Southeast region. 
- Similarly, RC's childcare centres are found in the West, East and Southeast region of Jurong West area, with a higher density found in the Southeast and Southwest region. 
- ST’s childcare centres are found in the East and Northwest region of Jurong West area with a higher density found in the East region.
- However, the legends of the 4 plots are different. 
- Although NT looks like it has the highest density of childcare centers, the legend range of NT and RC operators are much lower as compared to PT and ST. 
- PT has the largest range of density as compared to the other 3 operators.

### 6.1.2 Reveal density of childcare centres
Next, *intensity()* of spatstat package is used to reveal the density of childcare centres by operators as shown the code chunk below.

```{r echo=TRUE, eval=TRUE}
intensity(rescale(childcare_jw_ppp, 1000))
```

- The output reveals that childcare centres operate by PT has the highest density of 3.95 units per km square.  
- This is followed by 1.91 units per km square, 1.09 unit per km square and 0.82 unit per km square for ST, NT and RC respectively.

## 6.2 Second-order Multi-type Point Patterns Analysis: Cross K-Function

Now, we will analyse the relationship of PT and ST by using [*Kcross()*](https://rdrr.io/cran/spatstat/man/Kcross.html) of **spatstat** package. 

```{r eval=TRUE, echo = TRUE, fig.width=12, fig.height=8}
childcare_Kcross <- Kcross(childcare_jw_ppp, 
                           i="PT", j="ST",
                           correction='border')
plot(childcare_Kcross)
```

- The plot above reveals that there is a sign that the marked spatial point events are not independent spatially.  
- However, a hypothesis test is required to confirm the observation statistically.

### 6.2.1 Performing CSR testing on the Cross K-Function

The hypothesis and test are as follows:

- Ho = The distribution of ST childcare centres and NT chilcare centres are spatially independent.
- H1= The distribution of ST childcare centres and NT chilcare centres are NOT at spatially independent.
- The null hypothesis will be rejected if p-value is smaller than alpha value of 0.001 (i.e. at 99.9% confident interval).

In order to perform the CSR test, the [*envelope()*](https://rdrr.io/cran/spatstat/man/envelope.html) of **spatstat** package will be used.

```{r echo=TRUE, eval=TRUE}
childcare_Kcross.csr <- envelope(childcare_jw_ppp, Kcross, i="PT", j="ST", correction='border', nsim=999)
plot(childcare_Kcross.csr, xlab="distance(m)", xlim=c(0,500))
```

Question: Why nsim=999 is used?

- nsim refers to the number of permutations conducted to compute the envelope. The default is 999.
- Hence, we will be running 999+1 simulations of CSR. 

From the plot above: 

- There are signs that the distribution of childcare centres operate by NT and ST are not independent spatially.  
- Unfortunately, we failed to reject the null hypothesis because the empirical k-cross line is within the envelop of the 99.9% confident interval.  

## 6.3 Second-order Multi-tpye Point Patterns Analysis: Cross L-Function

In the code chunk below, *Lcross()* of **spatstat** package is used to compute Cross L-function.

```{r echo=TRUE, eval=TRUE}
childcare_Lcross <- Lcross(childcare_jw_ppp, i="PT", j="ST", correction='border')
plot(childcare_Lcross, . -r ~ r, 
     xlab = "distance(m)", 
     xlim=c(0, 500))
```

DIY: With reference to discussion in the earlier section, what observation(s) can you draw from the plot above?

- The plot above reveals that there is a sign that the marked spatial point events are not independent spatially.  
- However, a hypothesis test is required to confirm the observation statistically.

### 6.3.1 Performing CSR testing on the Cross L-Function

DIY: With reference to the example given in previous section, define the hypothesis null, hypothesis alternative and rejection criterion.

- Ho = The distribution of PT childcare centres and ST chilcare centres are spatially independent.
- H1= The distribution of PT childcare centres and ST chilcare centres are NOT at spatially independent.
- The null hypothesis will be rejected if p-value is smaller than alpha value of 0.001 (i.e. at 99.9% confident interval).

Similar to Cross-K-Function, we can perform the CSR test by using [*envelope()*](https://rdrr.io/cran/spatstat/man/envelope.html) of **spatstat** package will be used.

```{r fig.width=8, fig.height=6}
childcare_Lcross.csr <- envelope(childcare_jw_ppp, Lcross, i="PT", j="ST", correction='border', nsim=999)
plot(childcare_Lcross.csr, . -r ~ r, xlab="distance(m)", xlim=c(0,500))
```

DIY: Intepret the analysis result and draw conclusion with reference to the statistical testing result.

- There are signs that the distribution of childcare centres operate by PT and ST are not independent spatially.  
- Unfortunately, we failed to reject the null hypothesis because the empirical k-cross line is within the envelop of the 99.9% confident interval.  



