---
title: "Hands-on Exercise 6"
description: |
  In this hands on exercise, I learn how to derive spatial weights by using functions provided by spdep package and how to apply these spatial weights to compute spatially lagged values.
author:
  - name: Nor Aisyah
    url: https://www.linkedin.com/in/nor-aisyah/
date: 09-19-2021
output:
  distill::distill_article:
    self_contained: false
    toc: true
    toc_depth: 4
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```

# 1. Dataset used

- Hunan county boundary layer. This is a geospatial data set in ESRI shapefile format.
- Hunan_2012.csv: This csv file contains selected Hunan’s local development indicators in 2012.

# 2. Installing and Loading the R packages
```{r eval=TRUE, echo = TRUE}
packages = c('sf', 'readr', 'spdep', 'tmap', 'tidyverse')
for (p in packages){
  if(!require(p, character.only = T)){
    install.packages(p)
  }
  library(p,character.only = T)
}
```

More on the packages notes:

-import geospatial data using appropriate function(s) of **sf** package,
- import csv file using appropriate function of **readr** package,
perform relational join using appropriate join function of **dplyr** package,
- compute spatial weights using appropriate functions of **spdep** package, and
- calculate spatially lagged variables using appropriate functions of **spdep** package

# 3. Import data
## 3.1 Import shapefile into r environment
```{r eval=TRUE, echo = TRUE}
hunan <- st_read(dsn = "data/shapefile", 
                 layer = "Hunan")
```

## 3.2 Import csv file into r environment
```{r eval=TRUE, echo = TRUE}
hunan2012 <- read_csv("data/attribute/Hunan_2012.csv")
```

## 3.3 Perform relational join using **left_join()** of dplyr package.

- Used to update the attribute **table of hunan’s SpatialPolygonsDataFrame** with the attribute **fields of hunan2012 dataframe**

```{r eval=TRUE, echo = TRUE}
hunan <- left_join(hunan,hunan2012)
```

## 3.4 Visualise Regional Development Indicator

- Prepare a choropleth map showing the distribution of GDPPC 2012 by using **qtm()** of tmap package.

```{r eval=TRUE, echo = TRUE, fig.width=12, fig.height=8}
qtm(hunan, "GDPPC")
```

# 4. Computing Contiguity Spatial Weights

- Use **poly2nb() of spdep** package to compute **contiguity weight matrices** for the study area.

- poly2nb(): Construct neighbours list from polygon list

- This function **builds a neighbours list** based on regions with contiguous boundaries.

## 4.1 Computing (QUEEN) contiguity based neighbours

NOTE: 

- The default for 'queen' argument is TRUE. 
- If you do not specify to queen = FALSE, this function will **return a list of first order neighbours** using the Queen criteria.

```{r eval=TRUE, echo = TRUE}
wm_q <- poly2nb(hunan, queen=TRUE)
summary(wm_q)
```

- Summary report above shows that there are **88 area units** in Hunan (look at the no. of regions). 
- The **most connected area unit** has **11 neighbours** (look at 1 most connected region and the link).
- There are 2 area units with only 1 neighbours (look at 2 least connected regions and the link)


### 4.1.1 List the neighbouring polygons

- For each polygon in our polygon object, wm_q lists all neighboring polygons.
- To see the neighbors for the first polygon in the object, type:

```{r eval=TRUE, echo = TRUE}
wm_q[[1]]
```

- Results above show that **Polygon 1 has 5 neighbors**.
- The **numbers** represent the **polygon IDs** as stored in hunan SpatialPolygonsDataFrame class

### 4.1.2 Retrieve the county name of Polygon ID=1
```{r eval=TRUE, echo = TRUE}
hunan$County[1]
```

### 4.1.3 Reveal county names of the 5 neighboring polygons
```{r eval=TRUE, echo = TRUE}
hunan$NAME_3[c(2,3,4,57,85)]
```

### 4.1.4 Display the complete weight matrix by using str()
```{r eval=TRUE, echo = TRUE}
str(wm_q)
```


## 4.2 Computing (ROOK) contiguity based neighbours

- Note: See that we set the queen argument to FALSE

```{r eval=TRUE, echo = TRUE}
wm_r <- poly2nb(hunan, queen=FALSE)
summary(wm_r)
```

- Summary report above shows that there are **88 area units** in Hunan (look at the no. of regions). 
- The **most connected area unit** has **10 neighbours** (look at 1 most connected region and the link).
- There are 2 area units with only 1 neighbour (look at 2 least connected regions and the link)


## 4.3 Visualising contiguity weights

- As we are working with polygons, we need to get points in order to make the **connectivity graphs**. 
- Most typical method: **polygon centroids**
  - Calculate these in the sf package before moving onto the graphs
  - Getting Latitude and Longitude of Polygon Centroids
  - It is a little more complicated than just running st_centroid on the sf object as we need to get the coordinates in a separate data frame..
- **Mapping function**:  applies a given function to each element of a vector and returns a vector of the same length.
- **input vector**: will be the geometry column of us.bound.
- **function** will be st_centroid.
- Use **map_dbl** variation of map from the purrr package

### 4.3.1 Get only the longitude

- To get our longitude values, we map the st_centroid function over the geometry column of us.bound and access the longitude value through double bracket notation [[]] and 1.
- Allows us to get only the longitude, which is the first value in each centroid.

```{r eval=TRUE, echo = TRUE}
longitude <- map_dbl(hunan$geometry, ~st_centroid(.x)[[1]])
```

### 4.3.2 Get only the latitude

- Do the same for latitude with one key difference.
- We access the second value per each centroid with [[2]]

```{r eval=TRUE, echo = TRUE}
latitude <- map_dbl(hunan$geometry, ~st_centroid(.x)[[2]])
```

### 4.3.3 Put longitude and latitude into the same object

- Use cbind to put longitude and latitude into the same object.

```{r eval=TRUE, echo = TRUE}
coords <- cbind(longitude, latitude)
```

### 4.3.4 Check the first few observations

- Check the first few observations to see if things are formatted correctly

```{r eval=TRUE, echo = TRUE}
head(coords)
```

### 4.3.5 Plot Queen & Rook contiguity based neighbours maps (there is a difference)
```{r eval=TRUE, echo = TRUE}
par(mfrow=c(1,2))
plot(hunan$geometry, border="lightgrey")
plot(wm_q, coords, pch = 19, cex = 0.6, add = TRUE, col= "red", main="Queen Contiguity")
plot(hunan$geometry, border="lightgrey")
plot(wm_r, coords, pch = 19, cex = 0.6, add = TRUE, col = "red", main="Rook Contiguity")
```

**NOTE**: 

- There is actually a difference if you look closely at the bottom right of Queen Contiguity plot.
- There is 2 extra verticies at the bottom right.

## 4.4 Compute distance based neighbours

- Derive **distance-based weight matrices** by using **dnearneigh()** of spdep package
- The function identifies neighbours of region points by Euclidean distance with a distance band with **lower d1= and upper d2= bounds** controlled by the bounds= argument.
- If unprojected coordinates are used and either specified in the coordinates object x or with x as a two column matrix and longlat=TRUE, great circle distances in km will be calculated assuming the WGS84 reference ellipsoid.


### 4.4.1 Determine the cut-off distance

- To determine the upper limit for distance band:
  - Return a matrix with the indices of points belonging to the set of the k nearest neighbours of each other by using **knearneigh()** of spdep.
  - Convert the knn object returned by **knearneigh()** into a neighbours list of class nb with a list of integer vectors containing neighbour region number ids by using **knn2nb()**.
  - Return the length of neighbour relationship edges by using **nbdists()** of spdep. The function returns in the units of the coordinates if the coordinates are projected, in km otherwise.
  - Remove the list structure of the returned object by using **unlist()**.

```{r eval=TRUE, echo = TRUE}
k1 <- knn2nb(knearneigh(coords))
k1dists <- unlist(nbdists(k1, coords, longlat = TRUE))
summary(k1dists)
```

-  Summary report shows that the largest first nearest neighbour distance is **61.79 km**, so using this as the upper threshold gives **certainty** that all units will have at least one neighbour.

### 4.4.2 Computing fixed distance weight matrix using **dnearneigh()**
```{r eval=TRUE, echo = TRUE}
wm_d62 <- dnearneigh(coords, 0, 62, longlat = TRUE)
wm_d62
```

Quiz: What is the meaning of *Average number of links: 3.681818* shown above?
- It means that on average, there are about 3 neighbours in each region areas.

### 4.4.2.1 Use str() to display the content of wm_d62 weight matrix
```{r eval=TRUE, echo = TRUE}
str(wm_d62)
```

### 4.4.2.2 Display structure of weight matrix

- Another way to display the structure of the weight matrix is to combine table() and card() of spdep.

```{r eval=TRUE, echo = TRUE}
table(hunan$County, card(wm_d62))
```

### 4.4.3 Plotting fixed distance weight matrix
```{r eval=TRUE, echo = TRUE, fig.width=12, fig.height=8}
plot(hunan$geometry, border="lightgrey")
plot(wm_d62, coords, add=TRUE)
plot(k1, coords, add=TRUE, col="red", length=0.08)
```

- The **red** lines above show the **links of 1st nearest neighbours** 
- The **black** lines show the **links of neighbours within the cut-off distance of 62km**.
- Alternatively, we can plot both of them next to each other:

```{r eval=TRUE, echo = TRUE}
par(mfrow=c(1,2))
plot(hunan$geometry, border="lightgrey")
plot(k1, coords, add=TRUE, col="red", length=0.08, main="1st nearest neighbours")
plot(hunan$geometry, border="lightgrey")
plot(wm_d62, coords, add=TRUE, pch = 19, cex = 0.6, main="Distance link")
```

### 4.4.4 Computing adaptive distance weight matrix

- 1 of the characteristics of fixed distance weight matrix is that **more densely settled areas** (usually the urban areas) tend to have **more neighbours** 
- and the **less densely settled areas** (usually the rural counties) **tend to have lesser neighbours**.
- Having many neighbours smoothes the neighbour relationship across more neighbours.

#### 4.4.4.1 Control the numbers of neighbours directly

- It is possible to control the numbers of neighbours directly using k-nearest neighbours, either accepting asymmetric neighbours or imposing symmetry

```{r eval=TRUE, echo = TRUE}
knn6 <- knn2nb(knearneigh(coords, k=6))
knn6
```

Display the content of the matrix by using str():

```{r eval=TRUE, echo = TRUE}
str(knn6)
```

- Notice that each county has 6 neighbours

### 4.4.5 Plotting distance based neighbours

- Plot the weight matrix

```{r eval=TRUE, echo = TRUE}
plot(hunan$geometry, border="lightgrey")
plot(knn6, coords, pch = 19, cex = 0.6, add = TRUE, col = "red")
```

## 4.5 Weights based on IDW (Inverse Distance)

- Here, we will derive a spatial weight matrix based on **Inversed Distance** method.

### 4.5.1 Compute the distances between areas by using **nbdists()** of spdep.
```{r eval=TRUE, echo = TRUE}
dist <- nbdists(wm_q, coords, longlat = TRUE)
ids <- lapply(dist, function(x) 1/(x))
ids
```

## 4.6 Row-standardised weights matrix

- Need to assign weights to each neighboring polygon.
- The most intuitive way to summarize the neighbours’ values:
  - Assigning the fraction 1/(no. of neighbours) to each neighbouring county
  - Summing the weighted income values
  - This can be done by assigning each neighboring polygon **equal weight (style=“W”)**
- This method has 1 drawback:
  - Polygons along the edges of the study area will base their lagged values on fewer polygons thus potentially over- or under-estimating the true nature of the spatial autocorrelation in the data. 
  - For this example, we’ll stick with the style=“W” option for simplicity’s sake but note that other more robust options are available, notably **style=“B”**

- The zero.policy=TRUE option allows for lists of non-neighbors.
- This should be used with caution since the user may not be aware of missing neighbors in their dataset 
- However, a zero.policy of FALSE would return an error

### 4.6.1 Equal weight 
```{r eval=TRUE, echo = TRUE}
rswm_q <- nb2listw(wm_q, style="W", zero.policy = TRUE)
rswm_q
```

-  To see the weight of the first polygon’s four neighbors type

```{r eval=TRUE, echo = TRUE}
rswm_q$weights[10]
```

- Each neighbor is assigned a 0.2 of the total weight.
- When computing the average neighboring income values, each neighbor’s income will be multiplied by 0.2 before being tallied.

### 4.6.2 Row standardised distance weight matrix

- Using the same method, we can also derive a row standardised distance weight matrix by using the code chunk below.

```{r eval=TRUE, echo = TRUE}
rswm_ids <- nb2listw(wm_q, glist=ids, style="B", zero.policy=TRUE)
rswm_ids
```

```{r eval=TRUE, echo = TRUE}
rswm_ids$weights[1]
```

```{r eval=TRUE, echo = TRUE}
summary(unlist(rswm_ids$weights))
```

# 5. Application of Spatial Weight Matrix
We will create 4 different spatial lagged variables:

- spatial lag with row-standardized weights 
- spatial lag as a sum of neighbouring values
- spatial window average, and 
- spatial window sum

Note: 

What is a spatially lagged variable?

- With a neighbor structure defined by the non-zero elements of the spatial weights matrix W, a spatially lagged variable is a weighted sum or a weighted average of the neighbouring values for that variable.

## 5.1 Spatial lag with row-standardized weights
### 5.1.1 compute the average neighbor GDPPC

- Here, we compute the average neighbor GDPPC value for each polygon.
- These values are often referred to as **spatially lagged values**

```{r eval=TRUE, echo = TRUE}
GDPPC.lag <- lag.listw(rswm_q, hunan$GDPPC)
GDPPC.lag
```

### 5.1.2 Append spatially lag GDPPC values onto hunan SpatialPolygonDataFrame

```{r eval=TRUE, echo = TRUE}
lag.list <- list(hunan$NAME_3, lag.listw(rswm_q, hunan$GDPPC))
lag.res <- as.data.frame(lag.list)
colnames(lag.res) <- c("NAME_3", "lag GDPPC")
hunan <- left_join(hunan,lag.res)
```

- The following table shows the average neighboring income values (stored in the Inc.lag object) for each county.

```{r eval=TRUE, echo = TRUE}
head(hunan)
```

### 5.1.3 Plot both the GDPPC and spatial lag GDPPC for comparison

```{r eval=TRUE, echo = TRUE, fig.width=12, fig.height=8}
gdppc <- qtm(hunan, "GDPPC")
lag_gdppc <- qtm(hunan, "lag GDPPC")
tmap_arrange(gdppc, lag_gdppc, asp=1, ncol=2)
```

## 5.2 Spatial window sum

- The spatial window sum uses and includes the diagonal element.

### 5.2.1 Assign knn6 to a new variable 

- Why? Because we will directly alter its structure to add the diagonal elements

```{r eval=TRUE, echo = TRUE}
knn6a <- knn6
```

### 5.2.2 Add diagonal element to  neighbour list using **include.self()** from spdep.
```{r eval=TRUE, echo = TRUE}
include.self(knn6a)
```

### 5.2.3 Assign binary weights to the neighbour structure that includes the diagonal element
```{r eval=TRUE, echo = TRUE}
binary.knn6 <- lapply(knn6a, function(x) 0*x+1)
binary.knn6[1]
```

### 5.2.4 Use **nb2listw() and glist()** to explicitly assign weight values.

- nb2listw(): Spatial weights for neighbours lists

```{r eval=TRUE, echo = TRUE}
wm_knn6 <- nb2listw(knn6a, glist = binary.knn6, style = "B")
```

### 5.2.5 Compute the lag variable with lag.listw()

- With our new weight structure, we can compute the lag variable with lag.listw().

```{r eval=TRUE, echo = TRUE}
lag_knn6 <- lag.listw(wm_knn6, hunan$GDPPC)
```

### 5.2.6 Convert lag variable listw object into a data.frame by using **as.data.frame()**
```{r eval=TRUE, echo = TRUE}
lag.list.knn6 <- list(hunan$NAME_3, lag.listw(wm_knn6, hunan$GDPPC))
lag_knn6.res <- as.data.frame(lag.list.knn6)
colnames(lag_knn6.res) <- c("NAME_3", "lag_sum GDPPC")
```

**Note:** The third line of code in the code chunk above **renames** the field names of lag_knn6.res object into NAME_3 and lag_sum GDPPC respectively.

### 5.2.7 Append lag_sum GDPPC values onto hunan sf data.frame by using **left_join()** of dplyr package
```{r eval=TRUE, echo = TRUE}
hunan <- left_join(hunan, lag_knn6.res)
```

### 5.2.8 Plot the GDPPC and lag_sum GDPPC map 

- Lastly, qtm() of tmap package is used to plot the GDPPC and lag_sum GDPPC map next to each other for quick comparison.

```{r eval=TRUE, echo = TRUE, fig.width=12, fig.height=8}
gdppc <- qtm(hunan, "GDPPC")
lag_sum_gdppc <- qtm(hunan, "lag_sum GDPPC")
tmap_arrange(gdppc, lag_sum_gdppc, asp=1, ncol=2)
```

**NOTE**: For more effective comparison, it is advisable to use the core tmap mapping functions.

